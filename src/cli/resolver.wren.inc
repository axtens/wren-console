// Please do not edit this file. It has been generated automatically
// from `src/cli/resolver.wren` using `util/wren_to_c_string.py`

static const char* resolverModuleSource =
"class Resolver {\n"
"  static DEBUG { false }\n"
"  static debug(s) { \n"
"    if (this.DEBUG) System.print(s) \n"
"  }\n"
"  // load a dynamic library\n"
"  static loadLibrary(name, file, root) {\n"
"    var moduleDirectory = findModulesDirectory(root)\n"
"    if (moduleDirectory == null) {\n"
"      Fiber.abort(\"dynamic libraries require a wren_modules folder\")\n"
"    }\n"
"    var libPath = Path.new(moduleDirectory).join(file).toString\n"
"    if (!File.existsSync(libPath)) {\n"
"      Fiber.abort(\"library not found -- %(libPath)\")\n"
"    }\n"
"    File.loadDynamicLibrary(name, libPath)\n"
"    System.print(libPath)\n"
"  }\n"
"  static isLibrary(module) { module.contains(\":\") }\n"
"  // Applies the CLI's import resolution policy. The rules are:\n"
"  //\n"
"  // * If [module] starts with \"./\" or \"../\", it is a relative import, relative\n"
"  //   to [importer]. The resolved path is [name] concatenated onto the directory\n"
"  //   containing [importer] and then normalized.\n"
"  //\n"
"  //   For example, importing \"./a/./b/../c\" from \"./d/e/f\" gives you \"./d/e/a/c\".\n"
"  static resolveModule(importer, module, rootDir) {\n"
"    if (isLibrary(module)) {\n"
"      var pieces = module.split(\":\")\n"
"      module = pieces[1]\n"
"      var libraryName = pieces[0]\n"
"      var libraryFile = \"lib%(pieces[0]).dylib\"\n"
"      loadLibrary(libraryName, libraryFile, rootDir)\n"
"      return module\n"
"    }\n"
"    // System.print(\"importer: %(importer)  module: %(module)\")\n"
"    if (PathType.resolve(module) == PathType.SIMPLE) return module\n"
"\n"
"    var path = Path.new(importer).dirname.join(module)\n"
"    debug(\"resolved: %(path.toString)\")\n"
"    return path.toString\n"
"  }\n"
"\n"
"  // walks the tree starting with current root and attemps to find \n"
"  // `wren_modules` which will be used to resolve modules in addition\n"
"  // to built-in modules\n"
"  static findModulesDirectory(root) {\n"
"    var path = Path.new(root + \"/\")\n"
"    while(true) {\n"
"      var modules = path.join(\"wren_modules/\").toString \n"
"      debug(modules)\n"
"      if (File.existsSync(modules)) return modules\n"
"      if (path.isRoot) break\n"
"      path = path.up()\n"
"    }\n"
"  }\n"
"\n"
"  // searches for a module inside `wren_modules`\n"
"  //\n"
"  // If the module is a single bare name, treat it as a module with the same\n"
"  // name inside the package. So \"foo\" means \"foo/foo\".\n"
"  //\n"
"  // returns the path to the .wren file that needs to be loaded\n"
"  static findModule(root, module) {\n"
"    var segment\n"
"    if (module.contains(\"/\")) {\n"
"      segment = \"%(module).wren\"\n"
"    } else {\n"
"      segment = \"%(module)/%(module).wren\"\n"
"    }\n"
"    var moduleDirectory = Path.new(root).join(segment).toString\n"
"    debug(moduleDirectory)\n"
"    if (File.existsSync(moduleDirectory)) return moduleDirectory\n"
"  }\n"
"\n"
"  // Attempts to find the source for [module] relative to the current root\n"
"  // directory.\n"
"  //\n"
"  // Returns the filename to load if found, or `:%(module)` if not which\n"
"  // is the pattern C uses to attempt a built-in module load, ie:\n"
"  // returning `:os` will instruct C to use the internal `os` module.\n"
"  static loadModule(module, rootDir) {\n"
"    var type = PathType.resolve(module)\n"
"    if (type == PathType.ABSOLUTE || type == PathType.RELATIVE) {\n"
"      var path = \"%(module).wren\"\n"
"      return path\n"
"    }\n"
"\n"
"    var root = File.realPathSync(rootDir)\n"
"    debug(\"root: %(root)\")\n"
"    var wren_modules = findModulesDirectory(root)\n"
"    if (wren_modules != null) {\n"
"      var loc = findModule(wren_modules, module)\n"
"      if (loc!=null) {\n"
"        debug(\"found %(module) in %(wren_modules)\")\n"
"        return loc\n"
"      }\n"
"    }\n"
"    // must be built-in\n"
"    return \":%(module)\"\n"
"  }\n"
"}\n"
"\n"
"class Path {\n"
"  construct new(path) {\n"
"    _path = path\n"
"  }\n"
"  dirname {\n"
"    var pieces = _path.split(\"/\")\n"
"    return Path.new(pieces[0..-2].join(\"/\"))\n"
"    // debug(_path)\n"
"    // var pos = _path.indexOf(\"/\",-1)\n"
"    // debug(pos)\n"
"    // return Path.new(_path[0..pos])\n"
"  }\n"
"  isRoot { \n"
"    return _path == \"/\"  || (_path.count == 3 && path[1..2] == \":\\\\\") \n"
"  }\n"
"  up() {\n"
"    // TODO: we can do this without realPathSync\n"
"    return Path.new(File.realPathSync(_path + \"/..\"))\n"
"  }\n"
"  stripRelative(s) {\n"
"    if (s.startsWith(\"./\")) return s[2..-1]\n"
"    return s\n"
"  }\n"
"  join(path) {\n"
"    return Path.new((_path + \"/\" + stripRelative(path)).replace(\"//\",\"/\"))\n"
"  }\n"
"  toString { _path }\n"
"}\n"
"\n"
"class PathType {\n"
"  static SIMPLE { 1 }\n"
"  static ABSOLUTE { 2 }\n"
"  static RELATIVE { 3 }\n"
"\n"
"  static unixAbsolute(path) { path.startsWith(\"/\") }\n"
"  static windowsAbsolute(path) {\n"
"    // TODO: is this not escaped properly by the stock Python code generator\n"
"    return path.count >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  static resolve(path) {\n"
"    if (path.startsWith(\".\")) return PathType.RELATIVE\n"
"    if (unixAbsolute(path)) return PathType.ABSOLUTE\n"
"    if (windowsAbsolute(path)) return PathType.ABSOLUTE\n"
"\n"
"    return PathType.SIMPLE\n"
"  }\n"
"}\n"
"\n"
"class File {\n"
"  foreign static loadDynamicLibrary(name, path)\n"
"  foreign static existsSync(s)\n"
"  foreign static realPathSync(s)\n"
"}\n"
"\n"
"\n"
"\n";
