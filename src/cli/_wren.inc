// Generated automatically from src/cli/*.wren. Do not edit.
static const char* resolverModuleSource =
"class Resolver {\n"
"  static DEBUG { false }\n"
"  static debug(s) { \n"
"    if (this.DEBUG) System.print(s) \n"
"  }\n"
"  // load a dynamic library\n"
"  static loadLibrary(name, file, root) {\n"
"    var moduleDirectory = findModulesDirectory(root)\n"
"    if (moduleDirectory == null) {\n"
"      Fiber.abort(\"dynamic libraries require a wren_modules folder\")\n"
"    }\n"
"    var libPath = Path.new(moduleDirectory).join(file).toString\n"
"    if (!File.existsSync(libPath)) {\n"
"      Fiber.abort(\"library not found -- %(libPath)\")\n"
"    }\n"
"    // System.print(libPath)\n"
"    File.loadDynamicLibrary(name, libPath)\n"
"  }\n"
"  static isLibrary(module) { module.contains(\":\") }\n"
"  // Applies the CLI's import resolution policy. The rules are:\n"
"  //\n"
"  // * If [module] starts with \"./\" or \"../\", it is a relative import, relative\n"
"  //   to [importer]. The resolved path is [name] concatenated onto the directory\n"
"  //   containing [importer] and then normalized.\n"
"  //\n"
"  //   For example, importing \"./a/./b/../c\" from \"./d/e/f\" gives you \"./d/e/a/c\".\n"
"  static resolveModule(importer, module, rootDir) {\n"
"    if (isLibrary(module)) {\n"
"      var pieces = module.split(\":\")\n"
"      module = pieces[1]\n"
"      var libraryName = pieces[0]\n"
"      var libraryFile = \"lib%(pieces[0]).dylib\"\n"
"      loadLibrary(libraryName, libraryFile, rootDir)\n"
"      return module\n"
"    }\n"
"    // System.print(\"importer: %(importer)  module: %(module)\")\n"
"    if (PathType.resolve(module) == PathType.SIMPLE) return module\n"
"\n"
"    var path = Path.new(importer).dirname.join(module)\n"
"    debug(\"resolved: %(path.toString)\")\n"
"    return path.toString\n"
"  }\n"
"\n"
"  // walks the tree starting with current root and attemps to find \n"
"  // `wren_modules` which will be used to resolve modules in addition\n"
"  // to built-in modules\n"
"  static findModulesDirectory(root) {\n"
"    var path = Path.new(root + \"/\")\n"
"    while(true) {\n"
"      var modules = path.join(\"wren_modules/\").toString \n"
"      debug(modules)\n"
"      if (File.existsSync(modules)) return modules\n"
"      if (path.isRoot) break\n"
"      path = path.up()\n"
"    }\n"
"  }\n"
"\n"
"  // searches for a module inside `wren_modules`\n"
"  //\n"
"  // If the module is a single bare name, treat it as a module with the same\n"
"  // name inside the package. So \"foo\" means \"foo/foo\".\n"
"  //\n"
"  // returns the path to the .wren file that needs to be loaded\n"
"  static findModule(root, module) {\n"
"    var segment\n"
"    if (module.contains(\"/\")) {\n"
"      segment = \"%(module).wren\"\n"
"    } else {\n"
"      segment = \"%(module)/%(module).wren\"\n"
"    }\n"
"    var moduleDirectory = Path.new(root).join(segment).toString\n"
"    debug(moduleDirectory)\n"
"    if (File.existsSync(moduleDirectory)) return moduleDirectory\n"
"  }\n"
"\n"
"  // Attempts to find the source for [module] relative to the current root\n"
"  // directory.\n"
"  //\n"
"  // Returns the filename to load if found, or `:%(module)` if not which\n"
"  // is the pattern C uses to attempt a built-in module load, ie:\n"
"  // returning `:os` will instruct C to use the internal `os` module.\n"
"  static loadModule(module, rootDir) {\n"
"    var type = PathType.resolve(module)\n"
"    if (type == PathType.ABSOLUTE || type == PathType.RELATIVE) {\n"
"      var path = \"%(module).wren\"\n"
"      return path\n"
"    }\n"
"\n"
"    var root = File.realPathSync(rootDir)\n"
"    debug(\"root: %(root)\")\n"
"    var wren_modules = findModulesDirectory(root)\n"
"    if (wren_modules != null) {\n"
"      var loc = findModule(wren_modules, module)\n"
"      if (loc!=null) {\n"
"        debug(\"found %(module) in %(wren_modules)\")\n"
"        return loc\n"
"      }\n"
"    }\n"
"    // must be built-in\n"
"    return \":%(module)\"\n"
"  }\n"
"}\n"
"\n"
"class PathType {\n"
"  static SIMPLE { 1 }\n"
"  static ABSOLUTE { 2 }\n"
"  static RELATIVE { 3 }\n"
"\n"
"  static unixAbsolute(path) { path.startsWith(\"/\") }\n"
"  static windowsAbsolute(path) {\n"
"    // TODO: is this not escaped properly by the stock Python code generator\n"
"    return path.count >= 3 && path[1..2] == \":\\\\\"\n"
"  }\n"
"  static resolve(path) {\n"
"    if (path.startsWith(\".\")) return PathType.RELATIVE\n"
"    if (unixAbsolute(path)) return PathType.ABSOLUTE\n"
"    if (windowsAbsolute(path)) return PathType.ABSOLUTE\n"
"\n"
"    return PathType.SIMPLE\n"
"  }\n"
"}\n"
"\n"
"class File {\n"
"  foreign static loadDynamicLibrary(name, path)\n"
"  foreign static existsSync(s)\n"
"  foreign static realPathSync(s)\n"
"}\n"
"\n"
"\n"
"\n"
"\n\n"
"#module=resolver\n"
"class Path {\n"
"  construct new(path) { \n"
"    _path = path \n"
"    _sep = appearsWindows() ? \"\\\\\" : \"/\"\n"
"  }\n"
"  appearsWindows() {\n"
"    if (_path.contains(\"\\\\\")) return true\n"
"    if (_path.count>=2 && _path[1] == \":\") return true\n"
"  }\n"
"  sep { _sep || \"/\" }\n"
"  toString { _path }\n"
"  up() { join(\"..\") }\n"
"  join(path) { Path.new(_path + sep + path).normalize }\n"
"  isRoot { \n"
"    return _path == \"/\"  || \n"
"      // C:\n"
"      (_path.count == 2 && _path[1] == \":\") ||\n"
"      // F:\\\n"
"      (_path.count == 3 && _path[1..2] == \":\\\\\") \n"
"  }\n"
"  dirname {\n"
"    if (_path==\"/\") return this\n"
"    if (_path.endsWith(sep)) return Path.new(_path[0..-2])\n"
"    return up()\n"
"  }\n"
"  static split(path) {\n"
"    var segments = []\n"
"    var last = 0\n"
"    var i = 0\n"
"    while (i < path.count) {\n"
"      var char = path[i]\n"
"      if (char == \"/\" || char == \"\\\\\") {\n"
"        if (last==i) {\n"
"          segments.add(\"\")\n"
"        } else {\n"
"          segments.add(path[last...i])\n"
"        }\n"
"        last = i + 1\n"
"      }\n"
"      i = i + 1\n"
"    }\n"
"    if (last<path.count) {\n"
"      segments.add(path[last..-1])\n"
"    } else if (last==i) {\n"
"      segments.add(\"\")\n"
"    }\n"
"    return segments\n"
"  }\n"
"  normalize {\n"
"    // var paths = _path.split(sep)\n"
"    var paths = Path.split(_path)\n"
"    var finalPaths = []\n"
"    if (_path.startsWith(\"/\")) finalPaths.add(\"/\") \n"
"    if (paths[0]==\".\") finalPaths.add(\".\") \n"
"    for (path in paths) {\n"
"      var last = finalPaths.count>0 ? finalPaths[-1] : null\n"
"      if (path == \"..\") {\n"
"        if (last == \"/\") continue\n"
"        if (last == \"..\" || last == null) {\n"
"          finalPaths.add(\"%(path)\")  \n"
"        } else {\n"
"          if (finalPaths.count > 0) finalPaths.removeAt(finalPaths.count - 1)\n"
"        }\n"
"      } else if (path == \"\" || path == \".\") {\n"
"        continue\n"
"      } else {\n"
"        finalPaths.add(path)\n"
"      }\n"
"    }\n"
"    if (finalPaths.count>1 && finalPaths[0] == \"/\") finalPaths[0] = \"\"\n"
"    var path = finalPaths.join(sep)\n"
"    if (path == \"\") path = \".\"\n"
"    return Path.new(path)\n"
"  }\n"
"}";

// Generated automatically from src/cli/*.wren. Do not edit.
static const char* cliModuleSource =
"import \"repl\" for Repl, AnsiRepl, SimpleRepl\n"
"import \"os\" for Platform, Process\n"
"import \"io\" for Stdin, File, Stdout, Stat\n"
"import \"meta\" for Meta\n"
"\n"
"// TODO: Wren needs to expose System.version\n"
"// https://github.com/wren-lang/wren/issues/1016\n"
"class Wren {\n"
"  static CLI_VERSION { \"0.1\" }\n"
"  static VERSION { \"0.4\" }\n"
"}\n"
"\n"
"class CLI {\n"
"  static start() {\n"
"    // TODO: pull out argument processing into it's own class\n"
"    if (Process.allArguments.count >=2) {\n"
"      var flag = Process.allArguments[1]\n"
"      if (flag == \"--version\" || flag == \"-v\") {\n"
"        showVersion()\n"
"        return\n"
"      }\n"
"      if (flag == \"--help\" || flag == \"-h\") {\n"
"        showHelp()\n"
"        return\n"
"      }\n"
"      if (flag == \"-e\" && Process.allArguments.count >= 3) {\n"
"        var code = Process.allArguments[2]\n"
"        runCode(code,\"<eval>\")\n"
"        return\n"
"      }\n"
"    }\n"
"\n"
"    if (Process.allArguments.count == 1) {\n"
"      repl()\n"
"    } else {\n"
"      runFile(Process.allArguments[1])\n"
"    }\n"
"    Stdout.flush()\n"
"  }\n"
"  static versionInfo { \"wrenc v%(Wren.CLI_VERSION) (wren v%(Wren.VERSION))\" }\n"
"  static showVersion() {\n"
"    System.print(versionInfo) \n"
"  }\n"
"  static showHelp() {\n"
"    System.print(\"Usage: wrenc [file] [arguments...]\")\n"
"    System.print(\"\")\n"
"    System.print(\"Optional arguments:\")\n"
"    System.print(\"  -                read script from stdin\")\n"
"    System.print(\"  -h, --help       print wrenc command line options\")\n"
"    System.print(\"  -v, --version    print wrenc and Wren version\")\n"
"    System.print(\"  -e '[code]'      evaluate code\")\n"
"    System.print()\n"
"    System.print(\"Documentation can be found at https://github.com/joshgoebel/wren-console\")\n"
"    \n"
"  }\n"
"  static dirForModule(file) {\n"
"    return file.split(\"/\")[0..-2].join(\"/\")\n"
"  }\n"
"  static missingScript(file) {\n"
"    System.print(\"wrenc: No such file -- %(file)\")\n"
"  }\n"
"  static runCode(code,moduleName) {\n"
"    var fn = Meta.compile(code,moduleName)\n"
"    if (fn != null) {\n"
"      fn.call()\n"
"    } else {\n"
"      // TODO: Process.exit() \n"
"      // https://github.com/wren-lang/wren-cli/pull/74\n"
"      Fiber.abort(\"COMPILE ERROR, should exit 65\")\n"
"    }\n"
"  }\n"
"  static runInput() {\n"
"    var code = \"\"\n"
"    while(!Stdin.isClosed) code = code + Stdin.read()\n"
"    runCode(code,\"(script)\")\n"
"    return\n"
"  }\n"
"  static runFile(file) {\n"
"    if (file == \"-\") return runInput()\n"
"\n"
"    if (!File.exists(file)) return missingScript(file)\n"
"\n"
"    // TODO: absolute paths, need Path class likely\n"
"    var moduleName = \"./\" + file\n"
"    var code = File.read(file)\n"
"    setRootDirectory_(dirForModule(moduleName))\n"
"    // System.print(moduleName)\n"
"    runCode(code,moduleName)\n"
"  }\n"
"  static repl() {\n"
"    System.print(\"\"\" -\"\\//\"\"\")\n"
"    System.print(\"  \\\\_/    \\n%(versionInfo) (based on wren-cli@9c6b6933722)\") \n"
"    // \" fix broken VS Code highlighting (not understaning escapes)\n"
"\n"
"    Repl.start()\n"
"  }\n"
"  foreign static setRootDirectory_(dir) \n"
"}\n"
"CLI.start()\n";

